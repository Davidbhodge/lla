LLA stands for Lisp Linear Algebra, and aims to provide a convenient
and fast library for matrix operations in Common Lisp, by binding to
LAPACK (and later on, possibly other libraries).

1. STATUS

LLA is now in a pre-alpha stage.  This means that I cannot guarantee
that there will be no API changes or major reorganizations if they
prove to be beneficial, but they are unlikely to happen. 

2. INSTALLATION AND LOADING

Get LLA and its dependencies from Github.  Make sure that LAPACK and
BLAS libraries are installed on your system.  LLA should be able to
find and load these automatically.

Unless told otherwise, LLA expectes BLAS/LAPACK to use the (L)LP64
model [1] for integers -- that is to say, integer types in Fortran are
32 bit.  If integers are 64-bit, you should push :LLA-INT64 into
*FEATURES* before loading/compiling LLA.

[1] http://en.wikipedia.org/wiki/64-bit#Specific_C-language_data_models



** LLA aims to conform to the following design principles:

1. High level, user-friendly interface.

(solve a b) should return X from AX=B, regardless of whether A is a
dense matrix, an LU decomposition, or something else; similarly, X
should be a vector/matrix when B is.  Users should not need to
memorize names like DGESV, especially when CLOS makes it so easy to
deal with these things.  Also, you don't need to make sure that all
arguments are of the same type (eg complex-double): LLA will find the
common supertype for elements and convert if necessary.

2. Keeping it simple, no premature optimization.  

LLA provides methods for CL-NUM-UTILS's SUB, TRANSPOSE, ... interface.
Usually, these result in copies, as LLA doesn't handle "views" with
strides, transposes, etc.  If you find that this is a bottleneck,
please provide some real-life example code, but I would be highly
surprised at this.  There has to be some trade-off between complexity
and speed, and I would be unwilling to sacrifice the simplicity (and
more importantly, maintainability) of the implementation.  

3. Stay in Lisp and expose the innards of the objects as much as
possible.

LLA aims to take advantage of CL's high level facilities such as CLOS
and memory management.  Data is kept in Lisp arrays instead of foreign
arrays, so you can access it directly if you want that.  You also
benefit from garbage collection and all the clever stuff that comes
with the GC.  If you need more memory, just increase the heap size.

Currently, this means that only SBCL is supported.  Support for other
CL implementations is perfectly possible and will be done on demand
once the interface stabilizes.  It may not be super-fast (could
require copying), if your implementation does not have something like
SBCL's array pinning.  But you would hardly use such an implementation
for numerical calculations and expect it to be fast, would you?


** Acknowledgements

LLA was inspired by packages written by AJ Rossini, Rif, Mark Hoemmen
and others.  I have borrowed code (whenever allowed by their licenses)
and ideas freely from all of them.



Comments are very welcome.

Tamas Papp <tkpapp@gmail.com>
