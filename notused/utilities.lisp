(in-package :lla)

(declaim (optimize speed))

;;; extract all information, dimensions, mappings
;;; CODE: check dimensions, this is type independent
;;; find out smallest common type
;;; copy contents to memory (establish mapping by pinning?), transpose on demand
;;; CODE: call function with given parameters
;;; CODE: copy out stuff to various matrices?
;;; CODE: 

;;; allocation:
;;;  - copied in: yes/no
;;;  - copied out: yes/no
;;;  - do allocations, do scalars

;;;;  with-lapack-wrapper semantics
;;;;
;;;;  INPUT
;;;;  each input spec is of the form
;;;;  (name fortran-type vector length) or
;;;;  (name fortran-type matrix rows cols) or 
;;;;  (name fortran-type matrix rows cols :transposed)
;;;;
;;;;  semantics:
;;;;
;;;;   - Fortran-type can be general or integer.  General means that
;;;;     the type of all such matrices will be combined to the
;;;;     smallest common supertype.
;;;;   
;;;;   - Length, rows and cols must be symbols.  They will be bound
;;;;     inside body, also as pointers as needed.  Repeated symbols
;;;;     will be checked for equality (can be used to implement checks
;;;;     for conforming dimensions, etc).
;;;;
;;;;   - before body, all such vector and matrices are copied to a
;;;;     compatible memory area
;;;;
;;;;  OUTPUT 
;;;;  each output spec is of the form
;;;;  (name fortran-type vector length)
;;;;  (name fortran-type matrix rows cols) or
;;;;  (name fortran-type matrix rows cols :transposed) or
;;;;  (name :from another-name)
;;;;  (name :from another-name :transposed)
;;;;
;;;;  For the first three, a memory area will be allocated, similarly
;;;;  to inputs, but contents are copied from there after the body.
;;;;  For the last two forms, contents will be copied from a memory
;;;;  area used for an input, dimensions will be taken from there.
;;;;  Dimensions for the first three output types are not bound to
;;;;  anything, but they may be expressions that are evaluated (using
;;;;  previous bindings), not only symbols.
;;;;
;;;;  WORK
;;;;  (name fortran-type size)

;; 1. checks and bindings (array-type, rank, dimensions)
;; 2. finding the general type
;; 3. prologue
;; 4. characters placed in memory
;; 5. allocation (new pointer names autogenerated)
;;    input, outputs, work areas
;;    needed: name, size, type, pointer
;; 6. copying inputs.  needed: name, dims, type, pointer
;; 7. let array name->pointer
;;    8. let scalar-> pointer
;;    9. info
;;      10. call function, based on general
;;    11. check info
;; 12. copying outputs


;;;;
;;;;  Types and notation
;;;;
;;;;  For arrays, we distinguish the following fortran types: :integer,
;;;;  :single, :double, :complex-single and :complex-double.

(defun fortran-float-p (fortran-type)
  (find fortran-type '(:single :double :complex-single :complex-double)))

(defun fortran-double-p (fortran-type)
  (find fortran-type '(:double :complex-double)))

(defun fortran-complex-p (fortran-type)
  (find fortran-type '(:complex-single :complex-double)))

(define-condition fortran-type-not-recognized (error)
  ()
  (:documentation "Type is not recognized as a Fortran type."))

(defun fortran-type (lisp-type)
  "Map a number (typecode) indicating the type.  These can be combined
with logior to get the smallest common supertype (for the purposes of
this library, not CL), except for int32.  Uses pattern matching, and
should only be used on types returned by array-element-type."
  (match lisp-type
	 ('single-float :single)
	 ('double-float :double)
	 ((list 'complex 'single-float) :complex-single)
	 ((list 'complex 'double-float) :complex-double)
	 ((list 'unsigned-byte 32) :integer)
	 (_ (error 'fortran-type-not-recognized))))

(defun lisp-type (fortran-type)
  (ecase fortran-type
    (:single 'single-float)
    (:double 'double-float)
    (:complex-single '(complex single-float))
    (:complex-double '(complex double-float))
    (:integer '(unsigned-byte 32))))

(defun fortran-type-size (fortran-type)
  (ecase fortran-type
    (:single (foreign-type-size :float))
    (:double (foreign-type-size :double))
    (:complex-single (* 2 (foreign-type-size :float)))
    (:complex-double (* 2 (foreign-type-size :double)))
    (:integer (foreign-type-size :int32))))
  
(define-condition general-type-not-float (error)
  ()
  (:documentation "The general type derived from the arrays was not
  recognized as a float."))

(defun find-general-float-type (&rest arrays)
  "Find the smallest supertype of array element typess as a
fortran-type.  If this is not float, an error is signalled."
  (let ((fortran-types (mapcar (lambda (array)
				 (handler-case
				     (fortran-type 
				      (array-element-type array))
				   (fortran-type-not-recognized ()
				     (error "Failed to recognize ~a ~
as a Fortran-compatible type." (array-element-type array)))))
			       arrays)))
    (if (notevery #'fortran-float-p fortran-types)
	(error 'general-type-not-float)
	(let ((complex-p (some #'fortran-complex-p fortran-types))
	      (double-p (some #'fortran-double-p fortran-types)))
	  (cond
	    ((and complex-p double-p) :complex-double)
	    (complex-p :complex-single)
	    (double-p :double)
	    (t :single))))))

;;;;
;;;;  Functions that copy to/from memory, transposing if necessary
;;;;
;;;;  CFFI doesn't handle complex types yet, hence the need for a
;;;;  workaround.  These functions can copy with the types mapped to
;;;;  fortran-types, but they were not designed to be more general.
  

(defun copy-matrix-to-memory (matrix pointer fortran-type rows cols transpose-p)
  "Copy a matrix to memory, transposing and/or coercing if necessary."
  ;;; !!! unoptimized version
  (declare ((array * (* *)) matrix))
  (let ((coerce-p (not (eq (fortran-type (array-element-type matrix))
			   fortran-type))))
    (if coerce-p
	(let ((lisp-type (lisp-type fortran-type)))
	  (if transpose-p
	      (let ((i 0))
		(dotimes (c cols)
		  (dotimes (r rows)
		    (setf (mem-aref* pointer fortran-type i)
			  (coerce (aref matrix r c) lisp-type))
		    (incf i))))
	      (dotimes (i (* rows cols))
		(setf (mem-aref* pointer fortran-type i)
		      (coerce (row-major-aref matrix i) lisp-type))))))
	(if transpose-p
	    (let ((i 0))
	      (dotimes (c cols)
		(dotimes (r rows)
		  (setf (mem-aref* pointer fortran-type i)
			(aref matrix r c))
		  (incf i))))
	    (dotimes (i (* rows cols))
	      (setf (mem-aref* pointer fortran-type i)
		    (row-major-aref matrix i)))))
    pointer)

(defmacro coerce-branch (from to)

(flet ((convert (a)
	 (coerce a ,pointer-type)))
  


(defun copy-vector-to-memory (vector pointer length)
  "Copy a vector of double-float's to a memory location."
  ;;; !!! unoptimized version
  (declare (optimize speed))
  (declare ((simple-array double-float (*)) vector)
	   (fixnum length))
  (dotimes (i length)
    (declare ((integer 0 #.(round (/ most-positive-fixnum 10))) i))
    (setf (mem-aref pointer :double i)
	  (aref vector i))
    pointer))

(defparameter *a* (make-array 100000 :element-type 'double-float))
(with-foreign-object (ptr :double (array-total-size *a*))
;;  (let ((ptr (sb-alien:sap-alien ptr (* double-float))))
    (time
     (dotimes (i 1000)
       (copy-vector-to-memory *a* ptr (length *a*)))))

(defun stop-the-world (vector)
  (sb-sys:with-pinned-objects (vector)
    (mem-ref (sb-sys:vector-sap vector) :double)
    ))

(time
 (dotimes (i 1000)
   (stop-the-world *a*)))



	
(defun copy-matrix-from-memory (pointer fortran-type nrow ncol transpose-p)
  "Create a matrix from memory area, transposing if necessary."
  ;;; !!! unoptimized version
  (let ((matrix (make-array (list nrow ncol)
			   :element-type (lisp-type fortran-type))))
    (if transpose-p
	(let ((i 0))
	  (dotimes (c ncol)
	    (dotimes (r nrow)
	      (setf (aref matrix r c) 
		    (mem-aref* pointer fortran-type i))
	      (incf i))))
	(dotimes (i (* nrow ncol))
	  (setf (row-major-aref matrix i) 
		(mem-aref* pointer fortran-type i))))
    matrix))

(defun copy-vector-from-memory (pointer fortran-type length)
  "Create a vector from memory area, coercing if necessary."
  ;;; !!! unoptimized version
  (let ((vector (make-array length :element-type (lisp-type fortran-type))))
    (dotimes (i length)
      (setf (aref vector i) (mem-aref* pointer fortran-type i)))
    vector))

;;
;; Classes that follow are used exclusively inside the fortran wrapper
;; macros.  The reason for their existence is that keeping track of
;; what elements in a list got too complicated and error-prone.
;; 

(defclass memory-mapping-spec ()
  ((name :initarg :name :reader name :documentation "variable name")
   (pointer-name :initarg :pointer-name :reader pointer-name
		 :documentation "variable name for the pointer")
   (fortran-type :initarg :fortran-type
		 :documentation "fortran-type of elements, can be :general")))

(defclass array-spec (memory-mapping-spec)
  ((dimensions :initarg :dimensions
	       :documentation "a list of 1 (vector) or 2 (matrix) elements")
   (transpose-p :initarg :transpose-p
		:documentation "whether to transpose, only used for matrices")))

(defclass allocation-spec (memory-mapping-spec)
  ((size :initarg :size
	 :documentation "a list or an atom, which will be pasted directly, so things like (* n m) work fine.")))

;;;;
;;;;  utility functions that help interfacing with Fortran
;;;;

(defmacro with-fortran-scalar ((name type &optional (direction :input))
			       &body body)
  "Make sure that the contect of the variable name is the same as that
contained at the memory location pointer (when interpreted as type),
either before body (if the direction is :input) or after (:output), or
both (:input/output)."
  (assert (find direction '(:input :output :input/output)))
  (assert (symbolp name))
  (once-only (type)
    (with-unique-names (pointer)
      `(with-foreign-object (,pointer ,type 1)
	 ,(when (or (eq direction :input) (eq direction :input/output))
	    `(setf (mem-ref ,pointer ,type) ,name))
	 (multiple-value-prog1
	     (let ((,name ,pointer))
	       ,@body)
	   ,(when (or (eq direction :output) (eq direction :input/output))
	      `(setf ,name (mem-ref ,pointer ,type))))))))
  
(defmacro with-fortran-character ((name character)
				  &body body)
  "Allocate memory (1 byte) for the duration of body, assigning the
  character, then bind name to the memory location."
  (assert (symbolp name))
  `(with-foreign-object (,name :unsigned-char 1)
     (setf (mem-ref ,name :unsigned-char) (char-code ,character))
     ,@body))

(defmacro with-allocated-area ((pointer fortran-type size)
			       &body body)
  "Work around the limitations of cffi:with-foreign-object (doesn't
handle complex types).  Also convert from fortran-type.  Name is for
easier integration into the caller macro, ignored."
  (assert (symbolp pointer))
  (with-unique-names (cffi-size)
    `(let ((,cffi-size (* ,size (fortran-type-size ,fortran-type))))
       (with-foreign-pointer (,pointer ,cffi-size)
	 ,@body))))

(defmacro with-multiple-bindings (macro)
  "Define a version of `macro' with multiple arguments, given as a
list.  Application of `macro' will be nested.  The new name is the 
"
  (let ((plural (intern (format nil "~aS" macro))))
    `(defmacro ,plural (bindings &body body)
       ,(format nil "Multiple binding version of ~(~a~)." macro)
       (if bindings
	   `(,',macro ,(car bindings)
		     (,',plural ,(cdr bindings)
			       ,@body))
	   `(progn ,@body)))))

(with-multiple-bindings with-fortran-character)
(with-multiple-bindings with-fortran-scalar)
(with-multiple-bindings with-allocated-area)
;; (with-multiple-bindings with-output-array)

(defun process-specifications (specifications general-type-name)
  "Specifications is a list consisting of lists of the pattern

    (:input name fortran-type :vector length)
    (:input name fortran-type :matrix rows cols)
    (:input name fortran-type :matrix rows cols :transpose)
    (:output name)                 [ input area reused as output ]
    (:output name :transpose)      [ input area reused as output ]
    (:output name fortran-type :vector length)
    (:output name fortran-type :matrix rows cols)
    (:output name fortran-type :matrix rows cols :transpose)
    (:char name character)
    (:work name fortran-type size)

  Fortran-type can be :general, which is replaced with the symbol
  given in general-type-name.

  This function processes the specifications, returning

  (values general general-used-p input-arrays allocations 
          output-arrays characters)

  Errors are signalled when encountering
   - malformed speficiations,
   - repeated variable (eg within inputs, outputs or work areas,
"
  (let (;; list of inputs which are of the type :general
	general
	;; non-nil iff an input, output or work area is of type :general
	general-used-p
	;; input and arrays, type of array-spec, used for copying
	input-arrays
	output-arrays
	;; allocations, type of allocation-spec.  inputs, outputs (but
	;; not input-output arrays!) and work areas all end up here.
	allocations
	;; characters, type of (list name character)
	characters)
    (labels ((check-name (name)
	       "Signal an error if name was already used.  Not for
               input-output array names."
	       (cond
		 ((and (find name allocations :key #'name))
		  (error " ~a was already used for an input or an output array, or a work area" name))
		 ((find name characters :key #'first)
		  (error "~a was already used for a character" name))
		 (t (values))))
	     (resolve-type (fortran-type)
	       "Substitute variable name for general type when
               requested (and set general-used to non-nil), otherwise
               pass through fortran type."
	       (assert (symbolp fortran-type)) ;; !! maybe check it is
					       ;; one of :single, etc
	       (if (eq fortran-type :general)
		   (progn
		     (setf general-used-p t)
		     general-type-name)
		   fortran-type))
	     (allocated-size (dimensions)
	       "Calculate the allocated size.  Will be pasted
               directly, so if it is a list, it will be evaluated."
	       (match dimensions
		      ((list length) length)
		      ((list rows cols) `(* ,rows ,cols))))
	     (pointer-name (name)
	       "Generate a pointer name from a symbol."
	       (gensym (symbol-name name)))
	     (process-input-array (name fortran-type dimensions
					&optional transpose-p)
	       "Process input array."
	       ;; check uniqueness
	       (check-name name)
	       ;; if general, store name
	       (when (eq fortran-type :general)
		 (push name general))
	       ;; process specification
	       (let ((pointer-name (pointer-name name))
		     (type (resolve-type fortran-type)))
		 ;; information for bindings and copying input
		 (push (make-instance 'array-spec
				      :name name
				      :pointer-name pointer-name
				      :fortran-type type
				      :dimensions dimensions
				      :transpose-p transpose-p)
		       input-arrays)
		 ;; allocation
		 (push (make-instance 'allocation-spec
				      :name name
				      :pointer-name pointer-name
				      :fortran-type type
				      :size (allocated-size dimensions))
		       allocations)))
	     (process-input-output-array (name &optional transpose-p)
	       "Existing output array, inherits the properties of an
               input array except for transposing."
	       (let ((input-array (find name input-arrays :key #'name)))
		 (unless input-array
		   (error "can't copy output from array ~a: ~
                           no such input array" name))
		 ;; change transpose-p
		 (with-slots (name pointer-name fortran-type
				   dimensions) input-array
		   ;; output to be copied, no allocation
		   (push (make-instance 'array-spec 
					:name name
					:pointer-name pointer-name
					:fortran-type fortran-type
					:dimensions dimensions
					:transpose-p transpose-p)
			 output-arrays))))
	     (process-output-array (name fortran-type dimensions
					     &optional transpose-p)
	       "Freshly allocated output array."
	       (let ((pointer-name (pointer-name name))
		     (type (resolve-type fortran-type)))
		 ;; output to be copied
		 (push (make-instance 'array-spec
				      :name name
				      :pointer-name pointer-name
				      :fortran-type type
				      :dimensions dimensions
				      :transpose-p transpose-p)
		       output-arrays)
		 ;; allocation
		 (push (make-instance 'allocation-spec
				      :name name
				      :pointer-name pointer-name
				      :fortran-type type
				      :size (allocated-size dimensions))
		       allocations))))
      ;; preprocess process all arguments: verify syntax, and organize
      ;; information
      (mapc (lambda (specification)
	      (match specification
		     ;; input arrays
		     ((list :input name fortran-type :vector length)
		      (process-input-array name fortran-type 
					   (list length)))
		     ((list :input name fortran-type :matrix rows cols)
		      (process-input-array name fortran-type 
					   (list rows cols) nil))
		     ((list :input name fortran-type :matrix rows cols
			    :transposed)
		      (process-input-array name fortran-type 
					   (list rows cols) t))
		     ;; input-output arrays
		     ((list :output name)
		      (process-input-output-array name nil))
		     ((list :output name :transposed)
		      (process-input-output-array name t))
		     ;; output arrays - newly created
		     ((list :output name fortran-type :vector length)
		      (process-output-array name fortran-type 
						(list length)))
		     ((list :output name fortran-type :matrix rows cols)
		      (process-output-array name fortran-type 
						(list rows cols) nil))
		     ((list :output name fortran-type :matrix rows cols
			    :transposed)
		      (process-output-array name fortran-type 
						(list rows cols) t))
		     ;; work areas
		     ((list :work name fortran-type size)
		      (error "work areas not implemented yet"))
		     ;; characters
		     ((list :char name character)
		      (push (list name character) characters))
		     ;; no match, signal error
		     (_ (error "malformed specification ~a"
			       specification))))
	    specifications)
      ;; reverse specifications, so that they end up in the correct
      ;; order
      (values (nreverse general)
	      general-used-p
	      (nreverse input-arrays)
	      (nreverse allocations)
	      (nreverse output-arrays)
	      (nreverse characters)))))


(defmacro with-fortran-wrapper (prologue general-type-name
				(&rest specifications) &body body)
  "This macro
    - makes the content of the given vectors and matrices available
      at memory locations (see specifications below)
    - binds the dimensions to the given variables
    - binds the variable named general-type to the general (float) type
    - checks equality for variables that occur multiple times
    - copies the output according to specifications (see below)
    - calls prologue and body binding the pointers to the variable names.
"
  (assert (symbolp general-type-name))
  (bind (((:values general general-used-p input-arrays allocations 
		   output-arrays characters)
	  (process-specifications specifications general-type-name))
	 bindings)
    (labels ((gensym-if-bound (name)
	       "If name is in bindings, return symbol name created
	       with gensym, otherwise save it and return nil"
	       (if (find name bindings)
		   (gensym (symbol-name name))
		   (progn
		     (push name bindings)
		     nil)))
	     (checks-and-bindings (input-arrays-rest)
	       (if input-arrays-rest
		   ;; descend recursively
		   (with-slots (name dimensions)
		       (car input-arrays-rest)
		     (ecase (length dimensions)
		       ;; vectors
		       (1 (bind (((length) dimensions)
				 (gs-length (gensym-if-bound length)))
			    `(bind (((,(if gs-length gs-length length))
				     (array-dimensions ,name)))
			       ,@(if gs-length
				     `((assert (= ,gs-length ,length))))
			       ,(checks-and-bindings 
				 (cdr input-arrays-rest)))))
		       ;; matrices
		       (2 (bind (((rows cols) dimensions)
				 (gs-rows (gensym-if-bound rows))
				 (gs-cols (gensym-if-bound cols)))
			    `(bind (((,(if gs-rows gs-rows rows)
				       ,(if gs-cols gs-cols cols))
				     (array-dimensions ,name)))
			       ,@(if gs-rows
				     `((assert (= ,gs-rows ,rows))))
			       ,@(if gs-cols
				     `((assert (= ,gs-cols ,cols))))
			       ,(checks-and-bindings
				 (cdr input-arrays-rest)))))))
		   ;; REST of the body is here, non-recursively
		   ;; PHASE: finding general type
		   `(,@(if general
			   ;; bind general type
			   `(let ((,general-type-name
				   (find-general-float-type
				    ,@general))))
			   ;; important: no general type, leave unbound
			   (prog1 '(progn)
			     (when general-used-p
			       (error "general type used but it could ~
                                      not be derived, no inputs have it"))))
		       ;; PHASE: prologue
		       ,@(when prologue
			   prologue)
		       ;; PHASE: fortran characters
		       (with-fortran-characters ,characters
			 ;; PHASE: allocate memory
			 (with-allocated-areas
			     ,(mapcar (lambda (allocation-spec)
					(with-slots (pointer-name
						     fortran-type
						     size) allocation-spec
					  (list pointer-name
						fortran-type
						size)))
				      allocations)
			   ;; PHASE: copy in
			   ,@(mapcar (lambda (input-array)
				       (with-slots (name
						    pointer-name
						    fortran-type
						    dimensions
						    transpose-p) input-array
					 (match dimensions
						((list length)
						 `(copy-vector-to-memory 
						   ,name
						   ,pointer-name
						   ,fortran-type
						   ,length))
						((list rows cols)
						 `(copy-matrix-to-memory
						   ,name
						   ,pointer-name
						   ,fortran-type
						   ,rows ,cols
						   ,transpose-p)))))
				     input-arrays)
			   ;; PHASE: name/pointer bindings for all
			   ;; allocations  
			   (let (,@(mapcar (lambda (name-pointer-spec)
					     (with-slots (name 
							  pointer-name) 
						 name-pointer-spec
					       (list name pointer-name)))
				     allocations))
			     ;; PHASE: scalar/pointer bindings
			     (with-fortran-scalars ,(mapcar 
			     			     (lambda (spec)
			     			       (list spec
			     				     :int32))
			     			     bindings)
			       ;; PHASE: call body
			       ,@body)
			       ;; PHASE: copy out and return
			     (values 
			       ,@(mapcar 
				  (lambda (array-spec)
				    (with-slots (pointer-name
						 fortran-type
						 dimensions
						 transpose-p)
					array-spec
				      (match dimensions
					     ((list length)
					      `(copy-vector-from-memory
						,pointer-name
						,fortran-type
						,length))
					     ((list rows cols)
					      `(copy-matrix-from-memory
						,pointer-name
						,fortran-type
						,rows ,cols
						,transpose-p)))))
				  output-arrays)))))))))
      (checks-and-bindings input-arrays))))

(define-condition lapack-error (error)
  ((info :initarg :info :reader info)
   (lapack-procedure :initarg :lapack-procedure
		     :reader lapack-procedure))
  (:documentation "The lapack procedure returned a nonzero info
  code."))

(defun lapack-procedure-name (name general-type)
  "Return the Fortran procedure name based on name and general-type,
both of which are symbols, and so is the returned value."
  (intern
   (concatenate 'string (ecase general-type
			  (:single "%S")
			  (:double "%D")
			  (:complex-single "%C")
			  (:complex-double "%Z"))
		(symbol-name name))))

(defmacro with-lapack-wrapper (specifications &body body)
  "Wrapper macro for calling lapack procedures.  Specifications are
  the same as for with-fortran-wrapper.  Last sexp will be interpreted
  as a funcall, first atom will be used for the function name, and
  info is appended as the last argument."
  (let ((lapack-call (car (last body))))
    (with-unique-names (info info-pointer procedure-name)
      `(with-fortran-wrapper ,(butlast body) general-type ,specifications
	 (with-foreign-object (,info-pointer :int32)
	   (let ((,procedure-name (lapack-procedure-name 
				   ',(car lapack-call) general-type)))
	     (funcall ,procedure-name
		      ,@(cdr lapack-call) ,info-pointer)
	     (let ((,info (mem-ref ,info-pointer :int32)))
	       (unless (zerop ,info)
		 (error 'lapack-error :info ,info 
			:lapack-procedure ,procedure-name)))))))))

;;;  NOTES: bind output/work dimensions calculated expression, if it is not
;;;  a symbol


(let ((a (make-array '(3 4) :element-type 'double-float))
      (b (make-array 4 :element-type 'single-float)))
  (with-fortran-wrapper ((format t "general=~a~%" general-type)) general-type
      ((:input a :general :matrix m n)
       (:input b :general :vector n)
       (:output a)
       (:output b))
    (format t "foo~%")))

(with-foreign-object (foo :double 50)
  (copy-matrix-from-memory foo :double 4 5 nil)
  )


(defgeneric solve (a b))

(defmethod solve ((a array) (b array))
  (with-lapack-wrapper
      ((:input a :general :matrix n n :transposed)
       (:input b :general :matrix n m :transposed)
       (:output b :transposed)
       (:output ipiv :integer :vector n))
    (gesv n m a n ipiv b n)))

(defparameter *a* (make-array '(2 2) :element-type 'double-float
			      :initial-contents '((1d0 0d0) (0d0 1d0))))
(defparameter *b* (make-array '(2 2) :element-type 'double-float
			      :initial-contents '((1d0) (5d0))))
(solve *a* *a*)

(defun fill-array-randomly! (array &optional (max (coerce 1 (array-element-type array))))
  (let* ((size (array-total-size array)))
    (dotimes (i size)
      (setf (row-major-aref array i) (random max))))
  array)

(defparameter *a* (fill-array-randomly! (make-array '(50 50) :element-type 'double-float)))
(defparameter *b* (fill-array-randomly! (make-array '(50 2) :element-type 'double-float)))

(require :sb-sprof)
(sb-sprof:with-profiling (:report :flat :loop nil :show-progress t)
  (dotimes (i 10000)
    (solve *a* *b*)))



*a*


(defparameter *a1* (make-array '(2 2) :element-type 'double-float
			      :initial-contents '((1d0 2d0) (3d0 4d0))))


(with-foreign-object (a-ptr :double 4)
  (copy-matrix-to-memory *a1* a-ptr :double 2 2 nil)
  (copy-matrix-from-memory a-ptr :double 2 2 nil)
;  (mem-aref a-ptr :double 3)
) 
(with-foreign-object (a-ptr :double 4)
  (copy-matrix-to-memory *b* a-ptr :double 2 1 nil)
  (mem-aref a-ptr :double 1))

